/**
 * CrossPoint Calendar Worker
 * Generates a test BMP image for the CrossPoint e-ink display
 * Display: 480x800 pixels, 8-bit grayscale (CrossPoint supports 1, 2, 8, 24, 32 bpp)
 */

export interface Env {
  DISPLAY_WIDTH: string;
  DISPLAY_HEIGHT: string;
}

// BMP file generation for 8-bit grayscale (256 colors)
function createBMP(width: number, height: number, pixelData: Uint8Array): Uint8Array {
  // 8-bit grayscale = 256 colors, 1 byte per pixel
  const paddedRowSize = Math.ceil(width / 4) * 4; // Rows must be 4-byte aligned
  const pixelDataSize = paddedRowSize * height;

  // 256-color grayscale palette (4 bytes per color: B, G, R, 0)
  const paletteSize = 256 * 4;
  const headerSize = 14; // BMP header
  const dibHeaderSize = 40; // BITMAPINFOHEADER
  const fileSize = headerSize + dibHeaderSize + paletteSize + pixelDataSize;

  const buffer = new Uint8Array(fileSize);
  const view = new DataView(buffer.buffer);

  // BMP Header (14 bytes)
  buffer[0] = 0x42; // 'B'
  buffer[1] = 0x4D; // 'M'
  view.setUint32(2, fileSize, true); // File size
  view.setUint32(6, 0, true); // Reserved
  view.setUint32(10, headerSize + dibHeaderSize + paletteSize, true); // Pixel data offset

  // DIB Header - BITMAPINFOHEADER (40 bytes)
  view.setUint32(14, dibHeaderSize, true); // DIB header size
  view.setInt32(18, width, true); // Width
  view.setInt32(22, -height, true); // Height (negative = top-down)
  view.setUint16(26, 1, true); // Color planes
  view.setUint16(28, 8, true); // Bits per pixel (8-bit)
  view.setUint32(30, 0, true); // Compression (none)
  view.setUint32(34, pixelDataSize, true); // Image size
  view.setInt32(38, 2835, true); // X pixels per meter (72 DPI)
  view.setInt32(42, 2835, true); // Y pixels per meter (72 DPI)
  view.setUint32(46, 256, true); // Colors in palette
  view.setUint32(50, 256, true); // Important colors

  // 256-color grayscale palette
  const paletteOffset = headerSize + dibHeaderSize;
  for (let i = 0; i < 256; i++) {
    buffer[paletteOffset + i * 4 + 0] = i; // Blue
    buffer[paletteOffset + i * 4 + 1] = i; // Green
    buffer[paletteOffset + i * 4 + 2] = i; // Red
    buffer[paletteOffset + i * 4 + 3] = 0; // Reserved
  }

  // Pixel data (8-bit, 1 byte per pixel)
  const pixelOffset = headerSize + dibHeaderSize + paletteSize;
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const srcIdx = y * width + x;
      const dstIdx = pixelOffset + y * paddedRowSize + x;
      buffer[dstIdx] = pixelData[srcIdx];
    }
    // Padding bytes are already 0
  }

  return buffer;
}

// Simple text rendering (basic bitmap font)
const FONT_WIDTH = 8;
const FONT_HEIGHT = 12;

// Basic 8x12 font for digits and some chars (simplified)
const fontData: { [key: string]: number[] } = {
  '0': [0x3C,0x66,0x6E,0x76,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,0x00],
  '1': [0x18,0x38,0x18,0x18,0x18,0x18,0x7E,0x00,0x00,0x00,0x00,0x00],
  '2': [0x3C,0x66,0x06,0x1C,0x30,0x60,0x7E,0x00,0x00,0x00,0x00,0x00],
  '3': [0x3C,0x66,0x06,0x1C,0x06,0x66,0x3C,0x00,0x00,0x00,0x00,0x00],
  '4': [0x0C,0x1C,0x3C,0x6C,0x7E,0x0C,0x0C,0x00,0x00,0x00,0x00,0x00],
  '5': [0x7E,0x60,0x7C,0x06,0x06,0x66,0x3C,0x00,0x00,0x00,0x00,0x00],
  '6': [0x1C,0x30,0x60,0x7C,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,0x00],
  '7': [0x7E,0x06,0x0C,0x18,0x30,0x30,0x30,0x00,0x00,0x00,0x00,0x00],
  '8': [0x3C,0x66,0x66,0x3C,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,0x00],
  '9': [0x3C,0x66,0x66,0x3E,0x06,0x0C,0x38,0x00,0x00,0x00,0x00,0x00],
  ':': [0x00,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00],
  ' ': [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
  'T': [0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x00],
  'E': [0x7E,0x60,0x60,0x7C,0x60,0x60,0x7E,0x00,0x00,0x00,0x00,0x00],
  'S': [0x3C,0x66,0x60,0x3C,0x06,0x66,0x3C,0x00,0x00,0x00,0x00,0x00],
  'C': [0x3C,0x66,0x60,0x60,0x60,0x66,0x3C,0x00,0x00,0x00,0x00,0x00],
  'R': [0x7C,0x66,0x66,0x7C,0x6C,0x66,0x66,0x00,0x00,0x00,0x00,0x00],
  'O': [0x3C,0x66,0x66,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,0x00],
  'P': [0x7C,0x66,0x66,0x7C,0x60,0x60,0x60,0x00,0x00,0x00,0x00,0x00],
  'I': [0x3C,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,0x00],
  'N': [0x66,0x76,0x7E,0x7E,0x6E,0x66,0x66,0x00,0x00,0x00,0x00,0x00],
  'A': [0x18,0x3C,0x66,0x66,0x7E,0x66,0x66,0x00,0x00,0x00,0x00,0x00],
  'L': [0x60,0x60,0x60,0x60,0x60,0x60,0x7E,0x00,0x00,0x00,0x00,0x00],
  'D': [0x78,0x6C,0x66,0x66,0x66,0x6C,0x78,0x00,0x00,0x00,0x00,0x00],
  'M': [0x63,0x77,0x7F,0x6B,0x63,0x63,0x63,0x00,0x00,0x00,0x00,0x00],
  'F': [0x7E,0x60,0x60,0x7C,0x60,0x60,0x60,0x00,0x00,0x00,0x00,0x00],
  'W': [0x63,0x63,0x63,0x6B,0x7F,0x77,0x63,0x00,0x00,0x00,0x00,0x00],
  'H': [0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x00,0x00,0x00,0x00,0x00],
  'U': [0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,0x00],
  'J': [0x06,0x06,0x06,0x06,0x06,0x66,0x3C,0x00,0x00,0x00,0x00,0x00],
  'G': [0x3C,0x66,0x60,0x6E,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,0x00],
  'K': [0x66,0x6C,0x78,0x70,0x78,0x6C,0x66,0x00,0x00,0x00,0x00,0x00],
  'V': [0x66,0x66,0x66,0x66,0x66,0x3C,0x18,0x00,0x00,0x00,0x00,0x00],
  'X': [0x66,0x66,0x3C,0x18,0x3C,0x66,0x66,0x00,0x00,0x00,0x00,0x00],
  'Y': [0x66,0x66,0x66,0x3C,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x00],
  'a': [0x00,0x00,0x3C,0x06,0x3E,0x66,0x3E,0x00,0x00,0x00,0x00,0x00],
  'b': [0x60,0x60,0x7C,0x66,0x66,0x66,0x7C,0x00,0x00,0x00,0x00,0x00],
  'c': [0x00,0x00,0x3C,0x66,0x60,0x66,0x3C,0x00,0x00,0x00,0x00,0x00],
  'd': [0x06,0x06,0x3E,0x66,0x66,0x66,0x3E,0x00,0x00,0x00,0x00,0x00],
  'e': [0x00,0x00,0x3C,0x66,0x7E,0x60,0x3C,0x00,0x00,0x00,0x00,0x00],
  'f': [0x1C,0x36,0x30,0x7C,0x30,0x30,0x30,0x00,0x00,0x00,0x00,0x00],
  'g': [0x00,0x00,0x3E,0x66,0x66,0x3E,0x06,0x3C,0x00,0x00,0x00,0x00],
  'h': [0x60,0x60,0x7C,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00,0x00],
  'i': [0x18,0x00,0x38,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,0x00],
  'k': [0x60,0x60,0x66,0x6C,0x78,0x6C,0x66,0x00,0x00,0x00,0x00,0x00],
  'l': [0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,0x00],
  'm': [0x00,0x00,0x76,0x7F,0x6B,0x6B,0x63,0x00,0x00,0x00,0x00,0x00],
  'n': [0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00,0x00],
  'o': [0x00,0x00,0x3C,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,0x00],
  'p': [0x00,0x00,0x7C,0x66,0x66,0x7C,0x60,0x60,0x00,0x00,0x00,0x00],
  'r': [0x00,0x00,0x6E,0x76,0x60,0x60,0x60,0x00,0x00,0x00,0x00,0x00],
  's': [0x00,0x00,0x3E,0x60,0x3C,0x06,0x7C,0x00,0x00,0x00,0x00,0x00],
  't': [0x30,0x30,0x7C,0x30,0x30,0x36,0x1C,0x00,0x00,0x00,0x00,0x00],
  'u': [0x00,0x00,0x66,0x66,0x66,0x66,0x3E,0x00,0x00,0x00,0x00,0x00],
  'v': [0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x00,0x00,0x00,0x00,0x00],
  'w': [0x00,0x00,0x63,0x6B,0x6B,0x7F,0x36,0x00,0x00,0x00,0x00,0x00],
  'x': [0x00,0x00,0x66,0x3C,0x18,0x3C,0x66,0x00,0x00,0x00,0x00,0x00],
  'y': [0x00,0x00,0x66,0x66,0x66,0x3E,0x06,0x3C,0x00,0x00,0x00,0x00],
  '/': [0x06,0x0C,0x18,0x30,0x60,0x40,0x00,0x00,0x00,0x00,0x00,0x00],
  '.': [0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00],
  ',': [0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x30,0x00,0x00,0x00,0x00],
  '-': [0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
};

function drawChar(pixels: Uint8Array, width: number, x: number, y: number, char: string, color: number, scale: number = 1) {
  const data = fontData[char];
  if (!data) return;

  for (let row = 0; row < 8; row++) {
    const rowData = data[row];
    for (let col = 0; col < 8; col++) {
      if (rowData & (0x80 >> col)) {
        // Draw scaled pixel
        for (let sy = 0; sy < scale; sy++) {
          for (let sx = 0; sx < scale; sx++) {
            const px = x + col * scale + sx;
            const py = y + row * scale + sy;
            if (px >= 0 && px < width && py >= 0) {
              pixels[py * width + px] = color;
            }
          }
        }
      }
    }
  }
}

function drawText(pixels: Uint8Array, width: number, x: number, y: number, text: string, color: number, scale: number = 1) {
  let cx = x;
  for (const char of text) {
    drawChar(pixels, width, cx, y, char, color, scale);
    cx += 8 * scale;
  }
}

function drawCenteredText(pixels: Uint8Array, width: number, y: number, text: string, color: number, scale: number = 1) {
  const textWidth = text.length * 8 * scale;
  const x = Math.floor((width - textWidth) / 2);
  drawText(pixels, width, x, y, text, color, scale);
}

function fillRect(pixels: Uint8Array, width: number, height: number, x: number, y: number, w: number, h: number, color: number) {
  for (let py = y; py < y + h && py < height; py++) {
    for (let px = x; px < x + w && px < width; px++) {
      if (px >= 0 && py >= 0) {
        pixels[py * width + px] = color;
      }
    }
  }
}

function drawRect(pixels: Uint8Array, width: number, height: number, x: number, y: number, w: number, h: number, color: number, thickness: number = 1) {
  // Top
  fillRect(pixels, width, height, x, y, w, thickness, color);
  // Bottom
  fillRect(pixels, width, height, x, y + h - thickness, w, thickness, color);
  // Left
  fillRect(pixels, width, height, x, y, thickness, h, color);
  // Right
  fillRect(pixels, width, height, x + w - thickness, y, thickness, h, color);
}

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const width = parseInt(env.DISPLAY_WIDTH) || 480;
    const height = parseInt(env.DISPLAY_HEIGHT) || 800;

    // Create pixel buffer (8-bit grayscale, values 0-255)
    // 0 = black, 255 = white
    const pixels = new Uint8Array(width * height);

    // Fill with white
    pixels.fill(255);

    // Get current time
    const now = new Date();
    const timeStr = now.toLocaleTimeString('en-US', {
      hour: '2-digit',
      minute: '2-digit',
      hour12: false,
      timeZone: 'America/Los_Angeles'
    });
    const dateStr = now.toLocaleDateString('en-US', {
      weekday: 'long',
      month: 'long',
      day: 'numeric',
      timeZone: 'America/Los_Angeles'
    }).toUpperCase();

    // Draw header bar
    fillRect(pixels, width, height, 0, 0, width, 80, 0); // Black header

    // Draw time (large, white on black)
    drawCenteredText(pixels, width, 20, timeStr, 255, 5);

    // Draw date below header
    drawCenteredText(pixels, width, 100, dateStr, 0, 2);

    // Draw "CROSSPOINT CALENDAR" title
    drawCenteredText(pixels, width, 150, "CROSSPOINT CALENDAR", 80, 2);

    // Draw a border
    drawRect(pixels, width, height, 10, 180, width - 20, height - 200, 0, 2);

    // Draw test message
    drawCenteredText(pixels, width, 220, "TEST IMAGE", 0, 3);
    drawCenteredText(pixels, width, 280, "If you can read this", 64, 2);
    drawCenteredText(pixels, width, 320, "the calendar is working", 64, 2);

    // Draw grayscale test bars (now with 256 levels, show 16 bars)
    const barY = 400;
    const barHeight = 40;
    const barWidth = Math.floor((width - 40) / 16);
    for (let i = 0; i < 16; i++) {
      const gray = Math.round(i * 255 / 15);
      fillRect(pixels, width, height, 20 + i * barWidth, barY, barWidth, barHeight, gray);
    }
    drawCenteredText(pixels, width, barY + barHeight + 10, "GRAYSCALE TEST", 0, 1);

    // Draw footer
    const footerY = height - 60;
    drawCenteredText(pixels, width, footerY, "480 x 800 8 bit", 80, 2);

    // Generate BMP
    const bmp = createBMP(width, height, pixels);

    return new Response(bmp, {
      headers: {
        'Content-Type': 'image/bmp',
        'Content-Disposition': 'inline; filename="calendar.bmp"',
        'Cache-Control': 'no-cache',
      },
    });
  },
};
